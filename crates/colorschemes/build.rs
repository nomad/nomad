#![allow(clippy::format_collect)]

use std::fs::OpenOptions;
use std::io::{self, Write};
use std::path::Path;

/// TODO: docs
const COLORS_DIR: &str = "colors";

/// TODO: docs
const COLORSCHEMES_DIR: &str = "src/schemes";

/// TODO: docs
const STATIC_MODULE: &str = "_static";

struct Colorscheme {
    /// TODO: docs
    struct_name: String,

    /// TODO: docs
    colorscheme_name: String,

    /// TODO: docs
    module_name: String,
}

impl Colorscheme {
    fn api_name(&self) -> String {
        self.colorscheme_name
            .to_ascii_lowercase()
            .replace(' ', "_")
            .chars()
            .filter(|c| c.is_ascii_alphanumeric() || *c == '_')
            .collect()
    }

    fn colorscheme_file_name(&self) -> String {
        self.api_name().replace('_', "-")
    }
}

fn main() {
    let colorschemes_dir = Path::new(&COLORSCHEMES_DIR);

    let colorschemes = index_colorschemes(colorschemes_dir);

    // create_impls_module(
    //     &colorschemes,
    //     &colorschemes_dir.join(IMPLS_MODULE).with_extension("rs"),
    // )
    // .unwrap();

    create_static_module(
        &colorschemes,
        &colorschemes_dir.join(STATIC_MODULE).with_extension("rs"),
    )
    .unwrap();

    create_colors_dir(&colorschemes, Path::new(COLORS_DIR)).unwrap();

    println!("cargo:rerun-if-changed={}", COLORSCHEMES_DIR);
}

fn index_colorschemes(dir: &Path) -> Vec<Colorscheme> {
    let ayu_mirage = Colorscheme {
        struct_name: "AyuMirage".to_owned(),
        colorscheme_name: "Ayu Mirage".to_owned(),
        module_name: "ayu_mirage".to_owned(),
    };

    let colorschemes = vec![ayu_mirage];

    colorschemes
}

fn create_impls_module(
    colorschemes: &[Colorscheme],
    path: &Path,
) -> io::Result<()> {
    let mut contents = String::from(
        r#"//! [`LoadableColorscheme`] implementations for all colorschemes.
//!
//! This file is automatically generated by the build script.
//! Do not edit it manually.

use common::nvim;

use crate::{LoadableColorscheme, load_colorscheme};

"#,
    );

    for colorscheme in colorschemes {
        let implementation = format!(
            r#"
impl LoadableColorscheme for {}::{} {{
    fn name(&self) -> &'static str {{
        "{}"
    }}
    fn api_name(&self) -> &'static str {{
        "{}"
    }}
    fn load(&self) -> nvim::Result<()> {{
        load_colorscheme(self)
    }}
}}
"#,
            colorscheme.module_name,
            colorscheme.struct_name,
            colorscheme.colorscheme_name,
            colorscheme.api_name(),
        );

        contents.push_str(&implementation);
    }

    write_file(path, &contents)
}

fn create_static_module(
    colorschemes: &[Colorscheme],
    path: &Path,
) -> io::Result<()> {
    let colorscheme_names = {
        let mut names =
            colorschemes.iter().map(|c| c.api_name()).collect::<Vec<_>>();

        names.sort();

        names
            .into_iter()
            .map(|n| format!("    \"{n}\""))
            .collect::<Vec<_>>()
            .join(",\n")
    };

    let api_names_to_colorscheme_names = colorschemes
        .iter()
        .map(|c| {
            format!(
                "        \"{}\" => \"{}\"",
                c.api_name(),
                c.colorscheme_name
            )
        })
        .collect::<Vec<_>>()
        .join(",\n");

    let colorschemes = colorschemes
        .iter()
        .map(|c| {
            format!(
                "        (\"{}\", Box::<{}::{}>::default() as _)",
                c.colorscheme_name, c.module_name, c.struct_name
            )
        })
        .collect::<Vec<_>>()
        .join(",\n");

    let contents = format!(
        r#"//! This file is automatically generated by the build script.
//! Do not edit it manually.

use std::collections::HashMap;

use phf::phf_map;
use once_cell::sync::Lazy;

use super::*;
use crate::LoadableColorscheme;

static COLORSCHEMES: Lazy<
    HashMap<&'static str, Box<dyn LoadableColorscheme>>,
> = Lazy::new(|| {{
    HashMap::from_iter([
{}
    ])
}});

const COLORSCHEME_API_NAMES: &[&str] = &[
{}
];

const API_NAMES_TO_COLORSCHEME_NAMES: phf::Map<&'static str, &'static str> = phf_map! {{
{}
}};

pub(crate) fn colorschemes<'a>(
) -> &'a HashMap<&'static str, Box<dyn LoadableColorscheme>> {{
    &COLORSCHEMES
}}

pub(crate) fn colorscheme_api_names() -> &'static [&'static str] {{
    COLORSCHEME_API_NAMES
}}

pub(crate) fn api_name_to_colorscheme_name(
    api_name: &str,
) -> Option<&'static str> {{
    API_NAMES_TO_COLORSCHEME_NAMES.get(api_name).copied()
}}
"#,
        colorschemes, colorscheme_names, api_names_to_colorscheme_names,
    );

    write_file(path, &contents)
}

fn create_colors_dir(
    colorschemes: &[Colorscheme],
    path: &Path,
) -> io::Result<()> {
    std::fs::create_dir_all(path)?;

    for colorscheme in colorschemes {
        let path = path
            .join(&colorscheme.colorscheme_file_name())
            .with_extension("lua");

        let contents = format!(
            "require(\"mad\").colorschemes.load(\"{}\")",
            colorscheme.colorscheme_name
        );

        write_file(&path, &contents)?;
    }

    Ok(())
}

fn write_file(path: &Path, contents: &str) -> io::Result<()> {
    if std::fs::read(path).map(|c| c == contents.as_bytes()).unwrap_or(false) {
        Ok(())
    } else {
        OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(path)?
            .write_all(contents.as_bytes())
    }
}
